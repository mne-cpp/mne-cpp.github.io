"use strict";(globalThis.webpackChunkmne_cpp_website=globalThis.webpackChunkmne_cpp_website||[]).push([[5343],{85892(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"manual/tools-compute-raw-inverse","title":"mne_compute_raw_inverse","description":"Overview","source":"@site/docs/manual/tools-compute-raw-inverse.mdx","sourceDirName":"manual","slug":"/manual/tools-compute-raw-inverse","permalink":"/docs/manual/tools-compute-raw-inverse","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"mne_compute_raw_inverse","sidebar_label":"mne_compute_raw_inverse","sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"mne_compute_mne","permalink":"/docs/manual/tools-compute-mne"},"next":{"title":"mne_dipole_fit","permalink":"/docs/manual/tools-dipole-fit"}}');var a=n(74848),r=n(28453);const l={title:"mne_compute_raw_inverse",sidebar_label:"mne_compute_raw_inverse",sidebar_position:7},t="mne_compute_raw_inverse",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:2},{value:"Options",id:"options",level:2},{value:"Description",id:"description",level:2},{value:"Inverse Methods",id:"inverse-methods",level:3},{value:"Regularization (SNR)",id:"regularization-snr",level:3},{value:"Label-Based Analysis",id:"label-based-analysis",level:3},{value:"Output",id:"output",level:3},{value:"Examples",id:"examples",level:2},{value:"See Also",id:"see-also",level:2}];function o(e){const s={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"mne_compute_raw_inverse",children:"mne_compute_raw_inverse"})}),"\n",(0,a.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"mne_compute_raw_inverse"})," computes inverse solutions (MNE, dSPM, or sLORETA) from raw or evoked FIFF data using a pre-computed inverse operator. It supports label-restricted source estimation and outputs results as STC files."]}),"\n",(0,a.jsx)(s.p,{children:"This is a C++ port of the original MNE-C tool by Matti H\xe4m\xe4l\xe4inen."}),"\n",(0,a.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"mne_compute_raw_inverse [options]\n"})}),"\n",(0,a.jsx)(s.h2,{id:"options",children:"Options"}),"\n",(0,a.jsxs)(s.table,{children:[(0,a.jsx)(s.thead,{children:(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.th,{children:"Option"}),(0,a.jsx)(s.th,{children:"Description"})]})}),(0,a.jsxs)(s.tbody,{children:[(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--in <file>"})}),(0,a.jsxs)(s.td,{children:["Raw or evoked data input file ",(0,a.jsx)(s.strong,{children:"(required)"})]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--inv <file>"})}),(0,a.jsxs)(s.td,{children:["Inverse operator file ",(0,a.jsx)(s.strong,{children:"(required)"})]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--snr <value>"})}),(0,a.jsx)(s.td,{children:"SNR value to use for regularization (default: 1.0)"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--nave <number>"})}),(0,a.jsx)(s.td,{children:"Number of averages (default: 1 for raw, from data for evoked)"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--set <number>"})}),(0,a.jsx)(s.td,{children:"Evoked data set number to process (default: process all)"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--bmin <time>"})}),(0,a.jsx)(s.td,{children:"Baseline starting time in milliseconds"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--bmax <time>"})}),(0,a.jsx)(s.td,{children:"Baseline ending time in milliseconds"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--label <file>"})}),(0,a.jsx)(s.td,{children:"Label file to restrict processing to (can specify multiple)"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--labeldir <dir>"})}),(0,a.jsx)(s.td,{children:"Process all labels in directory, compute average waveform per label"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--out <file>"})}),(0,a.jsxs)(s.td,{children:["Output file name (needed when using ",(0,a.jsx)(s.code,{children:"--labeldir"}),")"]})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--picknormalcomp"})}),(0,a.jsx)(s.td,{children:"Pick current component normal to cortex only"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--spm"})}),(0,a.jsx)(s.td,{children:"Use dSPM noise-normalization method"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--sloreta"})}),(0,a.jsx)(s.td,{children:"Use sLORETA noise-normalization method"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--mricoord"})}),(0,a.jsx)(s.td,{children:"Output source locations in MRI coordinates"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--orignames"})}),(0,a.jsx)(s.td,{children:"Use original label file names in channel names"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--align_z"})}),(0,a.jsx)(s.td,{children:"Align waveform signs using surface normal information"})]}),(0,a.jsxs)(s.tr,{children:[(0,a.jsx)(s.td,{children:(0,a.jsx)(s.code,{children:"--labellist <file>"})}),(0,a.jsx)(s.td,{children:"Output label name list to specified file"})]})]})]}),"\n",(0,a.jsx)(s.h2,{id:"description",children:"Description"}),"\n",(0,a.jsx)(s.p,{children:"This tool applies a pre-computed inverse operator to MEG/EEG data to produce source estimates on the cortical surface. The inverse operator must be pre-computed and stored in a FIFF file."}),"\n",(0,a.jsx)(s.h3,{id:"inverse-methods",children:"Inverse Methods"}),"\n",(0,a.jsx)(s.p,{children:"Three methods are available for computing the source estimates:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"MNE (default)"})," \u2014 Standard minimum-norm estimate. Provides current amplitude estimates in physical units (Am)."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"dSPM"})," (",(0,a.jsx)(s.code,{children:"--spm"})," flag) \u2014 Dynamic Statistical Parametric Mapping. Produces noise-normalized estimates that are dimensionless statistical test variables. Reduces location bias compared to MNE."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"sLORETA"})," (",(0,a.jsx)(s.code,{children:"--sloreta"})," flag) \u2014 Standardized Low-Resolution Electromagnetic Tomography. Another noise normalization approach that uses the resolution matrix diagonal for variance estimation."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["For mathematical details on these methods, see ",(0,a.jsx)(s.a,{href:"inverse",children:"The Minimum-Norm Estimates"}),"."]}),"\n",(0,a.jsx)(s.h3,{id:"regularization-snr",children:"Regularization (SNR)"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"--snr"})," parameter controls the regularization of the inverse solution. The regularization parameter ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsxs)(s.msup,{children:[(0,a.jsx)(s.mi,{children:"\u03bb"}),(0,a.jsx)(s.mn,{children:"2"})]})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\lambda^2"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8141em"}}),(0,a.jsxs)(s.span,{className:"mord",children:[(0,a.jsx)(s.span,{className:"mord mathnormal",children:"\u03bb"}),(0,a.jsx)(s.span,{className:"msupsub",children:(0,a.jsx)(s.span,{className:"vlist-t",children:(0,a.jsx)(s.span,{className:"vlist-r",children:(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(s.span,{className:"mord mtight",children:"2"})})]})})})})})]})]})})]})," is related to the SNR by ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsxs)(s.msup,{children:[(0,a.jsx)(s.mi,{children:"\u03bb"}),(0,a.jsx)(s.mn,{children:"2"})]}),(0,a.jsx)(s.mo,{children:"\u2248"}),(0,a.jsx)(s.mn,{children:"1"}),(0,a.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,a.jsxs)(s.msup,{children:[(0,a.jsx)(s.mtext,{children:"SNR"}),(0,a.jsx)(s.mn,{children:"2"})]})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\lambda^2 \\approx 1/\\text{SNR}^2"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8141em"}}),(0,a.jsxs)(s.span,{className:"mord",children:[(0,a.jsx)(s.span,{className:"mord mathnormal",children:"\u03bb"}),(0,a.jsx)(s.span,{className:"msupsub",children:(0,a.jsx)(s.span,{className:"vlist-t",children:(0,a.jsx)(s.span,{className:"vlist-r",children:(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(s.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(s.span,{className:"mrel",children:"\u2248"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1.1373em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord",children:"1/"}),(0,a.jsxs)(s.span,{className:"mord",children:[(0,a.jsx)(s.span,{className:"mord text",children:(0,a.jsx)(s.span,{className:"mord",children:"SNR"})}),(0,a.jsx)(s.span,{className:"msupsub",children:(0,a.jsx)(s.span,{className:"vlist-t",children:(0,a.jsx)(s.span,{className:"vlist-r",children:(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.8873em"},children:(0,a.jsxs)(s.span,{style:{top:"-3.1362em",marginRight:"0.05em"},children:[(0,a.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(s.span,{className:"mord mtight",children:"2"})})]})})})})})]})]})]})]}),"."]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Higher SNR"})," \u2192 less regularization \u2192 noisier but potentially more detailed estimates"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Lower SNR"})," \u2192 more regularization \u2192 smoother estimates"]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["For averaged evoked data, typical SNR values are 1.0\u20133.0. The number of averages (",(0,a.jsx)(s.code,{children:"--nave"}),") is automatically taken into account."]}),"\n",(0,a.jsx)(s.h3,{id:"label-based-analysis",children:"Label-Based Analysis"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"--label"})," option restricts the inverse computation to a specific cortical region defined by a FreeSurfer label file. Multiple labels can be specified. This is useful for ROI-based analyses."]}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"--labeldir"})," option processes all labels in a directory and computes the average source waveform for each label, which is useful for atlas-based analyses."]}),"\n",(0,a.jsx)(s.h3,{id:"output",children:"Output"}),"\n",(0,a.jsxs)(s.p,{children:["The output is written as STC (source estimate) files, which contain the estimated source activity at each source space location over time. These files can be visualized using ",(0,a.jsx)(s.code,{children:"mne_inspect"})," or other MNE visualization tools."]}),"\n",(0,a.jsx)(s.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(s.p,{children:"Compute dSPM source estimates from evoked data:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"mne_compute_raw_inverse \\\n    --in sample_audvis-ave.fif \\\n    --inv sample_audvis-meg-oct6-inv.fif \\\n    --snr 3.0 \\\n    --spm\n"})}),"\n",(0,a.jsx)(s.p,{children:"Compute MNE estimates restricted to a label:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"mne_compute_raw_inverse \\\n    --in sample_audvis-ave.fif \\\n    --inv sample_audvis-meg-oct6-inv.fif \\\n    --snr 2.0 \\\n    --label auditory-lh.label \\\n    --picknormalcomp\n"})}),"\n",(0,a.jsx)(s.p,{children:"Process all labels in a directory:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"mne_compute_raw_inverse \\\n    --in sample_audvis-ave.fif \\\n    --inv sample_audvis-meg-oct6-inv.fif \\\n    --snr 3.0 --spm \\\n    --labeldir labels/ \\\n    --out label_timecourses\n"})}),"\n",(0,a.jsx)(s.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"tools-process-raw",children:"mne_process_raw"})," \u2014 Compute averaged evoked data and noise-covariance matrices used as inputs"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"tools-forward-solution",children:"mne_forward_solution"})," \u2014 Compute the forward solution needed for inverse operator creation"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"tools-dipole-fit",children:"mne_dipole_fit"})," \u2014 Alternative source localization via dipole fitting"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.a,{href:"inverse",children:"The Minimum-Norm Estimates"})," \u2014 Mathematical background for MNE, dSPM, and sLORETA"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},28453(e,s,n){n.d(s,{R:()=>l,x:()=>t});var i=n(96540);const a={},r=i.createContext(a);function l(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);