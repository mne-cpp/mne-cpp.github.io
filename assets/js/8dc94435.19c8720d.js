"use strict";(globalThis.webpackChunkmne_cpp_website=globalThis.webpackChunkmne_cpp_website||[]).push([[2815],{30474(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"development/api-connectivity","title":"Connectivity","description":"The Connectivity library (CONNECTIVITYLIB) computes functional connectivity metrics, stores the resulting networks, and provides graph-theoretic utilities. It is implemented in pure C++ with real-time capability in mind and imposes no modality-specific constraints \u2014 the same API works for MEG, EEG, and source-level data.","source":"@site/docs/development/api-connectivity.mdx","sourceDirName":"development","slug":"/development/api-connectivity","permalink":"/docs/development/api-connectivity","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Connectivity","sidebar_label":"Connectivity"},"sidebar":"developmentSidebar","previous":{"title":"Disp3D (RHI)","permalink":"/docs/development/api-disp3d"},"next":{"title":"MNE Scan","permalink":"/docs/development/scan"}}');var s=n(74848),r=n(28453);const c={title:"Connectivity",sidebar_label:"Connectivity"},d="Connectivity",o={},a=[{value:"Architecture",id:"architecture",level:2},{value:"Data Flow",id:"data-flow",level:3},{value:"Trial-Based Computation",id:"trial-based-computation",level:3},{value:"Usage",id:"usage",level:2},{value:"Supported Metrics",id:"supported-metrics",level:2}];function l(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"connectivity",children:"Connectivity"})}),"\n",(0,s.jsxs)(t.p,{children:["The Connectivity library (",(0,s.jsx)(t.code,{children:"CONNECTIVITYLIB"}),") computes functional connectivity metrics, stores the resulting networks, and provides graph-theoretic utilities. It is implemented in pure C++ with real-time capability in mind and imposes no modality-specific constraints \u2014 the same API works for MEG, EEG, and source-level data."]}),"\n",(0,s.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(t.p,{children:"The library is organized into three groups of classes:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Group"}),(0,s.jsx)(t.th,{children:"Key Classes"}),(0,s.jsx)(t.th,{children:"Role"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"API"})}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"Connectivity"}),", ",(0,s.jsx)(t.code,{children:"ConnectivitySettings"})]}),(0,s.jsx)(t.td,{children:"User-facing entry point \u2014 configure inputs, select metrics, launch computation"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"Metrics"})}),(0,s.jsxs)(t.td,{children:["One class per metric (e.g., ",(0,s.jsx)(t.code,{children:"ConnectivityPLI"}),")"]}),(0,s.jsx)(t.td,{children:"Implement the spectral/statistical estimator for each measure"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.strong,{children:"Network containers"})}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"Network"}),", ",(0,s.jsx)(t.code,{children:"NetworkNode"}),", ",(0,s.jsx)(t.code,{children:"NetworkEdge"})]}),(0,s.jsx)(t.td,{children:"Store and query the resulting connectivity graph"})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"data-flow",children:"Data Flow"}),"\n",(0,s.jsx)(t.mermaid,{value:"flowchart LR\n    A[ConnectivitySettings] --\x3e B[Connectivity::calculate]\n    B --\x3e C1[Metric 1]\n    B --\x3e C2[Metric 2]\n    C1 --\x3e D[Network]\n    C2 --\x3e D\n    D --\x3e E[NetworkNode / NetworkEdge]"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["The user populates a ",(0,s.jsx)(t.code,{children:"ConnectivitySettings"})," object with trial data, node positions, desired metrics, and sampling frequency."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Connectivity::calculate()"})," dispatches each requested metric to its dedicated class."]}),"\n",(0,s.jsxs)(t.li,{children:["Results are returned as one ",(0,s.jsx)(t.code,{children:"Network"})," per metric, containing ",(0,s.jsx)(t.code,{children:"NetworkNode"})," and ",(0,s.jsx)(t.code,{children:"NetworkEdge"})," objects."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"NetworkEdge"})," instances are stored as smart pointers, which keeps memory usage manageable for large, fully connected graphs. ",(0,s.jsx)(t.code,{children:"Network"})," also exposes functions for distance-matrix computation, basic graph measures, and weight-based thresholding."]}),"\n",(0,s.jsx)(t.h3,{id:"trial-based-computation",children:"Trial-Based Computation"}),"\n",(0,s.jsxs)(t.p,{children:["Connectivity is computed ",(0,s.jsx)(t.strong,{children:"across trials"}),", not across time. This design targets evoked-response experiments where data are segmented into stimulus-locked epochs. For resting-state recordings (no stimulus), the continuous data can be split into equally sized blocks and treated as pseudo-trials \u2014 a standard approach in resting-state connectivity studies."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"Time-resolved (sample-by-sample) connectivity is not currently supported. Use the trial-based approach for spontaneous data."})}),"\n",(0,s.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(t.p,{children:"The example below computes all-to-all Phase Lag Index (PLI) and Imaginary Coherence from MEG gradiometer epochs:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:'// Prepare input data\nFiffRawData raw("sample_audvis_raw.fif");\nRowVectorXi picks = raw.info.pick_types("grad");\nEigen::MatrixXi events;\nMNE::read_events("sample_audvis_raw-eve.fif", events);\n\n// Read epochs: -100 ms to 400 ms relative to event type 3\nMNEEpochDataList data;\ndata = MNEEpochDataList::readEpochs(raw, events, -0.1, 0.4, 3, picks);\n\n// Configure connectivity\nConnectivitySettings settings;\nsettings.setNodePositions(raw.info, picks);\nsettings.setConnectivityMethods(QStringList() << "pli" << "imagcohy");\nsettings.setSamplingFrequency(raw.info.sfreq);\nfor (MNEEpochData::SPtr pItem : data)\n    settings.append(pItem->epoch);\n\n// Compute \u2014 returns one Network per metric\nQList<Network> networks = Connectivity::calculate(settings);\n'})}),"\n",(0,s.jsx)(t.p,{children:"Source-level connectivity works identically \u2014 pass source-localized signals instead of sensor-level data."}),"\n",(0,s.jsx)(t.h2,{id:"supported-metrics",children:"Supported Metrics"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Metric"}),(0,s.jsx)(t.th,{children:"Keyword"}),(0,s.jsx)(t.th,{children:"Domain"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Correlation"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"cor"})}),(0,s.jsx)(t.td,{children:"Time"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Cross-Correlation"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"xcor"})}),(0,s.jsx)(t.td,{children:"Time"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Coherence"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"coh"})}),(0,s.jsx)(t.td,{children:"Frequency"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Imaginary Coherence"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"imagcohy"})}),(0,s.jsx)(t.td,{children:"Frequency"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Phase Locking Value"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"plv"})}),(0,s.jsx)(t.td,{children:"Phase"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Phase Lag Index"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"pli"})}),(0,s.jsx)(t.td,{children:"Phase"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Weighted Phase Lag Index"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"wpli"})}),(0,s.jsx)(t.td,{children:"Phase"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Unbiased Squared Phase Lag Index"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"uspli"})}),(0,s.jsx)(t.td,{children:"Phase"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Debiased Squared Weighted Phase Lag Index"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"dswpli"})}),(0,s.jsx)(t.td,{children:"Phase"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453(e,t,n){n.d(t,{R:()=>c,x:()=>d});var i=n(96540);const s={},r=i.createContext(s);function c(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);