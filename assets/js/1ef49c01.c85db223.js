"use strict";(globalThis.webpackChunkmne_cpp_website=globalThis.webpackChunkmne_cpp_website||[]).push([[3274],{94060(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>a,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"development/ci-ghactions","title":"Github Actions","description":"MNE-CPP uses GitHub Actions for all continuous integration (CI) work. GitHub Actions operates on repository events \u2014 pushes, pull requests, releases, and timers \u2014 which trigger workflows defined as YAML files in .github/workflows/. Each workflow contains one or more jobs, and each job runs a series of steps on a fresh virtual machine (runner). You can read more about the terminology in the GitHub Actions documentation.","source":"@site/docs/development/ci-ghactions.mdx","sourceDirName":"development","slug":"/development/ci-ghactions","permalink":"/docs/development/ci-ghactions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Github Actions","sidebar_label":"Github Actions"},"sidebar":"developmentSidebar","previous":{"title":"Continuous Integration","permalink":"/docs/development/ci"},"next":{"title":"Deployment","permalink":"/docs/development/ci-deployment"}}');var i=n(74848),r=n(28453);const l={title:"Github Actions",sidebar_label:"Github Actions"},o="Github Actions",c={},d=[{value:"Workflow Overview",id:"workflow-overview",level:2},{value:"How the Pull Request Workflow Works",id:"how-the-pull-request-workflow-works",level:2},{value:"How the Release Workflow Works",id:"how-the-release-workflow-works",level:2},{value:"Testing CI Without a Pull Request",id:"testing-ci-without-a-pull-request",level:2},{value:"Workflow File Structure",id:"workflow-file-structure",level:2},{value:"Secrets and Environment Variables",id:"secrets-and-environment-variables",level:2},{value:"Adding or Modifying a Workflow",id:"adding-or-modifying-a-workflow",level:2}];function h(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"github-actions",children:"Github Actions"})}),"\n",(0,i.jsxs)(s.p,{children:["MNE-CPP uses ",(0,i.jsx)(s.a,{href:"https://docs.github.com/en/actions",children:"GitHub Actions"})," for all continuous integration (CI) work. GitHub Actions operates on repository events \u2014 pushes, pull requests, releases, and timers \u2014 which trigger ",(0,i.jsx)(s.strong,{children:"workflows"})," defined as YAML files in ",(0,i.jsx)(s.code,{children:".github/workflows/"}),". Each workflow contains one or more ",(0,i.jsx)(s.strong,{children:"jobs"}),", and each job runs a series of ",(0,i.jsx)(s.strong,{children:"steps"})," on a fresh virtual machine (runner). You can read more about the terminology in the ",(0,i.jsx)(s.a,{href:"https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions",children:"GitHub Actions documentation"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"workflow-overview",children:"Workflow Overview"}),"\n",(0,i.jsx)(s.p,{children:"The following table summarizes every CI workflow in MNE-CPP:"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Event type"}),(0,i.jsx)(s.th,{children:"Workflow Name"}),(0,i.jsx)(s.th,{children:"Workflow Script"}),(0,i.jsx)(s.th,{children:"Effect"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Pull Requests"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"PullRequest"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://github.com/mne-tools/mne-cpp/blob/main/.github/workflows/pullrequest.yml",children:"pullrequest.yml"})}),(0,i.jsx)(s.td,{children:"Triggers checks to run on the PR code."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Pushes/Merges to ",(0,i.jsx)(s.code,{children:"main"})]}),(0,i.jsx)(s.td,{children:"`Linux"}),(0,i.jsx)(s.td,{children:"MacOS"}),(0,i.jsx)(s.td,{children:"Win"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Publishing a new release with tag syntax ",(0,i.jsx)(s.code,{children:"v0.x.y"})]}),(0,i.jsx)(s.td,{children:"`Linux"}),(0,i.jsx)(s.td,{children:"MacOS"}),(0,i.jsx)(s.td,{children:"Win"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Pushes to the ",(0,i.jsx)(s.code,{children:"docu"})," branch"]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"DocuTest"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://github.com/mne-tools/mne-cpp/blob/main/.github/workflows/docutest.yml",children:"docutest.yml"})}),(0,i.jsxs)(s.td,{children:["Creates a new version of the documentation website and makes them accessible via the repository's ",(0,i.jsx)(s.code,{children:"gh-pages"})," branch."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Pushes to the ",(0,i.jsx)(s.code,{children:"wasm"})," branch"]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"WasmTest"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://github.com/mne-tools/mne-cpp/blob/main/.github/workflows/wasmtest.yml",children:"wasmtest.yml"})}),(0,i.jsxs)(s.td,{children:["Creates new versions of the WebAssembly capable MNE-CPP applications and makes them accessible via the repository's ",(0,i.jsx)(s.code,{children:"gh-pages"})," branch."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Pushes to the ",(0,i.jsx)(s.code,{children:"testci"})," branch"]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"TestCI"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://github.com/mne-tools/mne-cpp/blob/main/.github/workflows/testci.yml",children:"testci.yml"})}),(0,i.jsx)(s.td,{children:"Triggers checks to run cross-platform build setups and tests without the need to create a Github PR."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Timer runs out"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"Coverity"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://github.com/mne-tools/mne-cpp/blob/main/.github/workflows/coverity.yml",children:"coverity.yml"})}),(0,i.jsxs)(s.td,{children:["Triggers every two days to run ",(0,i.jsx)(s.a,{href:"https://scan.coverity.com/projects/mne-tools-mne-cpp",children:"Coverity"})," static code analysis tools."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{children:["Pushes to the ",(0,i.jsx)(s.code,{children:"generateqt"})," branch"]}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"BuildQtBinaries"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"https://github.com/mne-tools/mne-cpp/blob/main/.github/workflows/buildqtbinaries.yml",children:"buildqtbinaries.yml"})}),(0,i.jsxs)(s.td,{children:["Triggers builds of all needed Qt versions and makes them accesible as ",(0,i.jsx)(s.a,{href:"https://help.github.com/en/actions/configuring-and-managing-workflows/persisting-workflow-data-using-artifacts",children:"artifacts via the Github Actions interface"}),"."]})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"how-the-pull-request-workflow-works",children:"How the Pull Request Workflow Works"}),"\n",(0,i.jsxs)(s.p,{children:["When a contributor opens or updates a pull request, ",(0,i.jsx)(s.code,{children:"pullrequest.yml"})," runs a build-and-test matrix across all supported platforms. The workflow typically:"]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Checks out"})," the PR branch."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Installs Qt"})," using a cached Qt installation or the ",(0,i.jsx)(s.code,{children:"aqtinstall"})," action."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Configures CMake"})," with ",(0,i.jsx)(s.code,{children:"BUILD_TESTS=ON"})," so that unit tests are included."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Builds"})," the entire project in Release mode."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Runs CTest"})," to execute all unit tests and reports pass/fail status back to the pull request."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The PR cannot be merged until all matrix jobs pass. This ensures that every change is validated on Windows, Linux, and macOS before it reaches the ",(0,i.jsx)(s.code,{children:"main"})," branch."]}),"\n",(0,i.jsx)(s.h2,{id:"how-the-release-workflow-works",children:"How the Release Workflow Works"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"release.yml"})," is the most complex workflow. It is triggered by two different events:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:["Pushes to ",(0,i.jsx)(s.code,{children:"main"})]})," \u2014 produces a ",(0,i.jsx)(s.em,{children:"development release"})," (nightly build). Dynamically linked binaries are built for all three desktop platforms and uploaded to the ",(0,i.jsx)(s.code,{children:"DevBuilds"})," release on GitHub."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:["Publishing a tagged release (",(0,i.jsx)(s.code,{children:"v0.x.y"}),")"]})," \u2014 produces a ",(0,i.jsx)(s.em,{children:"stable release"}),". Both dynamically and statically linked binaries are built, deployment scripts bundle Qt dependencies, and the resulting archives are uploaded as release assets."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Each platform job follows the same high-level pattern: install Qt, configure CMake, build, deploy (bundle Qt libraries), package into an archive, and upload."}),"\n",(0,i.jsx)(s.h2,{id:"testing-ci-without-a-pull-request",children:"Testing CI Without a Pull Request"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"testci"})," branch provides a convenient way to run the full CI matrix without opening a pull request. Push your changes to the ",(0,i.jsx)(s.code,{children:"testci"})," branch on your fork:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"git push origin <yourBranch>:testci -f\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Then check the ",(0,i.jsx)(s.strong,{children:"Actions"})," tab in your fork's GitHub page. This is especially useful for debugging platform-specific build failures before submitting a PR."]}),"\n",(0,i.jsx)(s.h2,{id:"workflow-file-structure",children:"Workflow File Structure"}),"\n",(0,i.jsxs)(s.p,{children:["All workflow YAML files live in ",(0,i.jsx)(s.code,{children:".github/workflows/"})," and follow a common structure:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:"name: WorkflowName\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install Qt\n        # ...\n      - name: Configure\n        run: cmake -B build -S . -DCMAKE_BUILD_TYPE=Release\n      - name: Build\n        run: cmake --build build --parallel\n      - name: Test\n        run: cd build && ctest --output-on-failure\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Key elements include the ",(0,i.jsx)(s.strong,{children:"trigger"})," (",(0,i.jsx)(s.code,{children:"on:"}),"), the ",(0,i.jsx)(s.strong,{children:"matrix strategy"})," for cross-platform builds, and the ",(0,i.jsx)(s.strong,{children:"steps"})," that install dependencies, compile, test, and optionally deploy."]}),"\n",(0,i.jsx)(s.h2,{id:"secrets-and-environment-variables",children:"Secrets and Environment Variables"}),"\n",(0,i.jsxs)(s.p,{children:["Some workflows require GitHub repository secrets (configured in ",(0,i.jsx)(s.strong,{children:"Settings \u2192 Secrets and variables \u2192 Actions"}),"):"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Secret"}),(0,i.jsx)(s.th,{children:"Used by"}),(0,i.jsx)(s.th,{children:"Purpose"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"GITHUB_TOKEN"})}),(0,i.jsx)(s.td,{children:"All release workflows"}),(0,i.jsx)(s.td,{children:"Automatically provided; used to upload release assets"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"COVERITY_TOKEN"})}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"coverity.yml"})}),(0,i.jsx)(s.td,{children:"Authentication token for Coverity Scan"})]})]})]}),"\n",(0,i.jsx)(s.h2,{id:"adding-or-modifying-a-workflow",children:"Adding or Modifying a Workflow"}),"\n",(0,i.jsx)(s.p,{children:"To add a new workflow:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Create a new ",(0,i.jsx)(s.code,{children:".yml"})," file in ",(0,i.jsx)(s.code,{children:".github/workflows/"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Define the trigger event (",(0,i.jsx)(s.code,{children:"on:"}),") \u2014 push, pull_request, schedule, or workflow_dispatch."]}),"\n",(0,i.jsxs)(s.li,{children:["Define one or more jobs with the appropriate runner (",(0,i.jsx)(s.code,{children:"runs-on:"}),") and steps."]}),"\n",(0,i.jsxs)(s.li,{children:["Test the workflow by pushing to a feature branch or using ",(0,i.jsx)(s.code,{children:"workflow_dispatch"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["To modify an existing workflow, edit the corresponding ",(0,i.jsx)(s.code,{children:".yml"})," file and push the change. If the modification affects the PR workflow, open a PR to see the results immediately."]})]})}function a(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453(e,s,n){n.d(s,{R:()=>l,x:()=>o});var t=n(96540);const i={},r=t.createContext(i);function l(e){const s=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);