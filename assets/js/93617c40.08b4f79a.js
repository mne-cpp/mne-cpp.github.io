"use strict";(globalThis.webpackChunkmne_cpp_website=globalThis.webpackChunkmne_cpp_website||[]).push([[3738],{44466(e,t,s){s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"manual/tools-compute-mne","title":"mne_compute_mne","description":"Overview","source":"@site/docs/manual/tools-compute-mne.mdx","sourceDirName":"manual","slug":"/manual/tools-compute-mne","permalink":"/docs/manual/tools-compute-mne","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"title":"mne_compute_mne","sidebar_label":"mne_compute_mne","sidebar_position":12},"sidebar":"docsSidebar","previous":{"title":"mne_inverse_operator","permalink":"/docs/manual/tools-inverse-operator"},"next":{"title":"mne_compute_raw_inverse","permalink":"/docs/manual/tools-compute-raw-inverse"}}');var i=s(74848),r=s(28453);const d={title:"mne_compute_mne",sidebar_label:"mne_compute_mne",sidebar_position:12},o="mne_compute_mne",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:2},{value:"Options",id:"options",level:2},{value:"Description",id:"description",level:2}];function a(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"mne_compute_mne",children:"mne_compute_mne"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"mne_compute_mne"})," computes MNE, dSPM, or sLORETA source estimates from evoked data using a pre-computed forward solution and noise covariance. It supports advanced options for label restriction, baseline correction, dipole snapshots, predicted sensor data, and more."]}),"\n",(0,i.jsx)(t.p,{children:"This is a C++ port of the original MNE-C tool by Matti H\xe4m\xe4l\xe4inen."}),"\n",(0,i.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"mne_compute_mne [options]\n"})}),"\n",(0,i.jsx)(t.h2,{id:"options",children:"Options"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--in <file>"})}),(0,i.jsx)(t.td,{children:"Evoked data input file (required)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--fwd <file>"})}),(0,i.jsx)(t.td,{children:"Forward solution file (required)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--cov <file>"})}),(0,i.jsx)(t.td,{children:"Noise covariance matrix file (required)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--out <file>"})}),(0,i.jsx)(t.td,{children:"Output source estimate file (required)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--snr <value>"})}),(0,i.jsx)(t.td,{children:"SNR value for regularization"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--method <type>"})}),(0,i.jsx)(t.td,{children:"Inverse method: mne, dSPM, sLORETA"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--label <file>"})}),(0,i.jsx)(t.td,{children:"Restrict estimation to label (repeatable)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--labeldir <dir>"})}),(0,i.jsx)(t.td,{children:"Process all labels in directory"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--baseline <tmin> <tmax>"})}),(0,i.jsx)(t.td,{children:"Baseline correction interval (ms)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--collapse"})}),(0,i.jsx)(t.td,{children:"Collapse source estimates across labels"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--scaling <factor>"})}),(0,i.jsx)(t.td,{children:"Scale output data"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--dip <file>"})}),(0,i.jsx)(t.td,{children:"Output dipole snapshot file"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--pick <time>"})}),(0,i.jsx)(t.td,{children:"Extract source estimate at specific time (ms)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--pred <file>"})}),(0,i.jsx)(t.td,{children:"Output predicted sensor data"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"--overwrite"})}),(0,i.jsx)(t.td,{children:"Overwrite output file if it exists"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(t.p,{children:"This tool computes source estimates from evoked data using a forward solution and noise covariance. It supports label-based analysis, baseline correction, dipole snapshots, and predicted sensor data output. The output is compatible with MNE-CPP and MNE-Python."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453(e,t,s){s.d(t,{R:()=>d,x:()=>o});var n=s(96540);const i={},r=n.createContext(i);function d(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);