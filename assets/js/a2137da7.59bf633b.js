"use strict";(globalThis.webpackChunkmne_cpp_website=globalThis.webpackChunkmne_cpp_website||[]).push([[7971],{44372(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"development/scan-plugin","title":"Creating a new plugin","description":"MNE Scan\'s functionality is extended through plugins. Each plugin is a shared library that is loaded at runtime. This guide shows how to create a new MNE Scan plugin, from scaffolding to integration.","source":"@site/docs/development/scan-plugin.mdx","sourceDirName":"development","slug":"/development/scan-plugin","permalink":"/docs/development/scan-plugin","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Creating a new plugin","sidebar_label":"Creating a Plugin"},"sidebar":"developmentSidebar","previous":{"title":"Acquisition Plugins","permalink":"/docs/development/scan-acq"},"next":{"title":"MNE Analyze","permalink":"/docs/development/analyze"}}');var s=i(74848),l=i(28453);const r={title:"Creating a new plugin",sidebar_label:"Creating a Plugin"},a="Creating a New Plugin",d={},c=[{value:"Plugin Categories",id:"plugin-categories",level:2},{value:"Getting Started with the DummyToolbox",id:"getting-started-with-the-dummytoolbox",level:2},{value:"Plugin Structure",id:"plugin-structure",level:2},{value:"Key Virtual Functions",id:"key-virtual-functions",level:2},{value:"<code>clone()</code>",id:"clone",level:3},{value:"<code>init()</code>",id:"init",level:3},{value:"<code>unload()</code>",id:"unload",level:3},{value:"<code>getName()</code>",id:"getname",level:3},{value:"<code>setupWidget()</code>",id:"setupwidget",level:3},{value:"<code>run()</code>",id:"run",level:3},{value:"Connectors: Input and Output",id:"connectors-input-and-output",level:2},{value:"CMakeLists.txt",id:"cmakeliststxt",level:2},{value:"Static Building",id:"static-building",level:2},{value:"Building and Testing",id:"building-and-testing",level:2},{value:"Checklist",id:"checklist",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"creating-a-new-plugin",children:"Creating a New Plugin"})}),"\n",(0,s.jsx)(n.p,{children:"MNE Scan's functionality is extended through plugins. Each plugin is a shared library that is loaded at runtime. This guide shows how to create a new MNE Scan plugin, from scaffolding to integration."}),"\n",(0,s.jsx)(n.h2,{id:"plugin-categories",children:"Plugin Categories"}),"\n",(0,s.jsxs)(n.p,{children:["MNE Scan distinguishes between three plugin categories, each with a corresponding abstract base class in ",(0,s.jsx)(n.code,{children:"src/applications/mne_scan/libs/scShared/"}),":"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Category"}),(0,s.jsx)(n.th,{children:"Base Class"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Examples"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Sensor"})," (acquisition)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AbstractSensor"})}),(0,s.jsx)(n.td,{children:"Provides data from hardware devices or simulations"}),(0,s.jsx)(n.td,{children:"FiffSimulator, BabyMEG, LSLAdapter"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Algorithm"})," (processing)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AbstractAlgorithm"})}),(0,s.jsx)(n.td,{children:"Applies real-time processing to the data stream"}),(0,s.jsx)(n.td,{children:"Filtering, Averaging, SourceLocalization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"IO"})," (output)"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AbstractIOPlugin"})}),(0,s.jsx)(n.td,{children:"Writes data to disk or forwards it to other systems"}),(0,s.jsx)(n.td,{children:"FileWriter"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Your new plugin must inherit from one of these base classes depending on its role in the pipeline."}),"\n",(0,s.jsx)(n.h2,{id:"getting-started-with-the-dummytoolbox",children:"Getting Started with the DummyToolbox"}),"\n",(0,s.jsxs)(n.p,{children:["The easiest way to create a new plugin is to start from the ",(0,s.jsx)(n.strong,{children:"DummyToolbox"})," template:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Copy the ",(0,s.jsx)(n.code,{children:"dummytoolbox"})," folder under ",(0,s.jsx)(n.code,{children:"src/applications/mne_scan/plugins/dummytoolbox"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Rename the folder and all files to match your new plugin name."}),"\n",(0,s.jsxs)(n.li,{children:["In all source files, replace ",(0,s.jsx)(n.code,{children:"DummyToolbox"})," / ",(0,s.jsx)(n.code,{children:"dummytoolbox"})," with your plugin name."]}),"\n",(0,s.jsxs)(n.li,{children:["Update the ",(0,s.jsx)(n.code,{children:"CMakeLists.txt"})," inside your new plugin folder with the correct target name and source files."]}),"\n",(0,s.jsxs)(n.li,{children:["Register your plugin in the parent ",(0,s.jsx)(n.code,{children:"src/applications/mne_scan/plugins/CMakeLists.txt"})," by adding an ",(0,s.jsx)(n.code,{children:"add_subdirectory()"})," call for your plugin folder."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The DummyToolbox source can also be viewed on ",(0,s.jsx)(n.a,{href:"https://github.com/mne-tools/mne-cpp/tree/main/src/applications/mne_scan/plugins/dummytoolbox",children:"GitHub"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"plugin-structure",children:"Plugin Structure"}),"\n",(0,s.jsx)(n.p,{children:"A typical MNE Scan plugin consists of:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"File"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"myplugin.h / .cpp"})}),(0,s.jsx)(n.td,{children:"Main plugin class \u2014 inherits from the appropriate abstract base class"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"myplugin_global.h"})}),(0,s.jsxs)(n.td,{children:["Shared export/import macros (",(0,s.jsx)(n.code,{children:"Q_DECL_EXPORT"})," / ",(0,s.jsx)(n.code,{children:"Q_DECL_IMPORT"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"myplugin.json"})}),(0,s.jsx)(n.td,{children:"Plugin metadata (name, version)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"CMakeLists.txt"})}),(0,s.jsx)(n.td,{children:"Build configuration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FormFiles/"})}),(0,s.jsxs)(n.td,{children:["Optional Qt Designer ",(0,s.jsx)(n.code,{children:".ui"})," files for the plugin GUI"]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"key-virtual-functions",children:"Key Virtual Functions"}),"\n",(0,s.jsx)(n.p,{children:"Every plugin must implement the following virtual functions from its base class:"}),"\n",(0,s.jsx)(n.h3,{id:"clone",children:(0,s.jsx)(n.code,{children:"clone()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns a new instance of the plugin (not a copy). Used by the plugin manager during loading:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"QSharedPointer<AbstractPlugin> MyPlugin::clone() const\n{\n    return QSharedPointer<AbstractPlugin>(new MyPlugin);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"init",children:(0,s.jsx)(n.code,{children:"init()"})}),"\n",(0,s.jsx)(n.p,{children:"Called after all plugins are loaded into the Plugin Manager. Use it to allocate resources, initialize parameters, and set up internal data structures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'void MyPlugin::init()\n{\n    m_pOutput = PluginOutputData<RealTimeMultiSampleArray>::create(this, "MyPlugin Out", "MyPlugin output data");\n    m_outputConnectors.append(m_pOutput);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"unload",children:(0,s.jsx)(n.code,{children:"unload()"})}),"\n",(0,s.jsx)(n.p,{children:"Called when the application shuts down. Release resources and clean up here."}),"\n",(0,s.jsx)(n.h3,{id:"getname",children:(0,s.jsx)(n.code,{children:"getName()"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the plugin name as it appears in the MNE Scan GUI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'QString MyPlugin::getName() const\n{\n    return "My Plugin";\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"setupwidget",children:(0,s.jsx)(n.code,{children:"setupWidget()"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns a ",(0,s.jsx)(n.code,{children:"QWidget*"})," that serves as the plugin's configuration dialog. The user opens this from the plugin toolbar. Return ",(0,s.jsx)(n.code,{children:"nullptr"})," if no setup is needed."]}),"\n",(0,s.jsx)(n.h3,{id:"run",children:(0,s.jsx)(n.code,{children:"run()"})}),"\n",(0,s.jsxs)(n.p,{children:["The main processing loop. This function runs in a separate thread. For an ",(0,s.jsx)(n.strong,{children:"algorithm plugin"}),", it typically reads data from an input connector, processes it, and writes results to an output connector:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void MyPlugin::run()\n{\n    while(!isInterruptionRequested()) {\n        // Wait for new data\n        Eigen::MatrixXd matData = m_pInput->getValue();\n\n        // Process data\n        Eigen::MatrixXd matResult = processData(matData);\n\n        // Send to output\n        m_pOutput->measurementData()->setValue(matResult);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"connectors-input-and-output",children:"Connectors: Input and Output"}),"\n",(0,s.jsxs)(n.p,{children:["Plugins communicate through ",(0,s.jsx)(n.strong,{children:"connectors"}),". Input connectors receive data from upstream plugins; output connectors send data downstream."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// In init(): create an output connector\nm_pOutput = PluginOutputData<RealTimeMultiSampleArray>::create(this, "Out", "Output data");\nm_outputConnectors.append(m_pOutput);\n\n// In init(): create an input connector\nm_pInput = PluginInputData<RealTimeMultiSampleArray>::create(this, "In", "Input data");\nm_inputConnectors.append(m_pInput);\n'})}),"\n",(0,s.jsx)(n.p,{children:"MNE Scan's pipeline GUI allows the user to wire connectors between plugins by drawing connections."}),"\n",(0,s.jsx)(n.h2,{id:"cmakeliststxt",children:"CMakeLists.txt"}),"\n",(0,s.jsxs)(n.p,{children:["A minimal ",(0,s.jsx)(n.code,{children:"CMakeLists.txt"})," for a plugin:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cmake",children:"set(TARGET_NAME myplugin)\n\nadd_library(${TARGET_NAME} SHARED\n    myplugin.h\n    myplugin.cpp\n    myplugin_global.h\n)\n\ntarget_link_libraries(${TARGET_NAME}\n    PRIVATE\n        scShared\n        mne_utils\n        mne_fiff\n        Qt6::Core\n        Qt6::Widgets\n)\n\n# Install the plugin to the runtime plugins directory\ninstall(TARGETS ${TARGET_NAME}\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/mne_scan_plugins\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}/mne_scan_plugins\n)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"static-building",children:"Static Building"}),"\n",(0,s.jsxs)(n.p,{children:["When building statically, MNE Scan needs to be told about plugins at compile time. Add a ",(0,s.jsx)(n.code,{children:"Q_IMPORT_PLUGIN"})," macro in ",(0,s.jsx)(n.code,{children:"src/applications/mne_scan/mne_scan/main.cpp"})," under the ",(0,s.jsx)(n.code,{children:"#ifdef STATICBUILD"})," guard:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#ifdef STATICBUILD\nQ_IMPORT_PLUGIN(MyPlugin)\n#endif\n"})}),"\n",(0,s.jsx)(n.p,{children:"The CMake configuration handles the rest of the static build setup automatically."}),"\n",(0,s.jsx)(n.h2,{id:"building-and-testing",children:"Building and Testing"}),"\n",(0,s.jsx)(n.p,{children:"After adding your plugin, rebuild MNE-CPP with CMake:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cmake -B build -S . -DCMAKE_BUILD_TYPE=Release\ncmake --build build --target myplugin --parallel\n"})}),"\n",(0,s.jsx)(n.p,{children:"The compiled plugin library will be placed in the output directory where MNE Scan discovers it at runtime. Launch MNE Scan and verify that your plugin appears in the plugin toolbar."}),"\n",(0,s.jsx)(n.h2,{id:"checklist",children:"Checklist"}),"\n",(0,s.jsx)(n.p,{children:"Before submitting your plugin as a pull request, verify:"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Plugin folder added under ",(0,s.jsx)(n.code,{children:"src/applications/mne_scan/plugins/"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.code,{children:"add_subdirectory()"})," added to the parent ",(0,s.jsx)(n.code,{children:"CMakeLists.txt"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Plugin has a ",(0,s.jsx)(n.code,{children:"*_global.h"})," file with export macros"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All virtual functions from the base class are implemented"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ",(0,s.jsx)(n.code,{children:"Q_IMPORT_PLUGIN"})," added for static builds"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Plugin compiles and loads successfully in MNE Scan"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Unit tests written for any processing logic (see ",(0,s.jsx)(n.a,{href:"/docs/development/writingtest",children:"Writing Tests"}),")"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var t=i(96540);const s={},l=t.createContext(s);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);