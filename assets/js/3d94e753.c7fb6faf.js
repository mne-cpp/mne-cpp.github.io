"use strict";(globalThis.webpackChunkmne_cpp_website=globalThis.webpackChunkmne_cpp_website||[]).push([[769],{51115(e,i,n){n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"development/scan-acq","title":"Acquisition plugins in MNE Scan","description":"Acquisition plugins (also called sensor plugins) are the entry point for all data in MNE Scan. They interface with hardware devices or data sources \u2014 EEG amplifiers, MEG systems, file readers, or simulated signals \u2014 and stream data into the real-time processing pipeline.","source":"@site/docs/development/scan-acq.mdx","sourceDirName":"development","slug":"/development/scan-acq","permalink":"/docs/development/scan-acq","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Acquisition plugins in MNE Scan","sidebar_label":"Acquisition Plugins"},"sidebar":"developmentSidebar","previous":{"title":"MNE Scan","permalink":"/docs/development/scan"},"next":{"title":"Creating a Plugin","permalink":"/docs/development/scan-plugin"}}');var t=n(74848),r=n(28453);const a={title:"Acquisition plugins in MNE Scan",sidebar_label:"Acquisition Plugins"},l="Acquisition Plugins in MNE Scan",c={},d=[{value:"Three-Tier Architecture",id:"three-tier-architecture",level:2},{value:"Example: gUSBamp EEG Driver",id:"example-gusbamp-eeg-driver",level:2},{value:"Data Flow",id:"data-flow",level:2},{value:"Starting Acquisition",id:"starting-acquisition",level:3},{value:"Stopping Acquisition",id:"stopping-acquisition",level:3},{value:"Key Base Classes",id:"key-base-classes",level:2},{value:"Implementing a New Acquisition Plugin",id:"implementing-a-new-acquisition-plugin",level:2}];function o(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"acquisition-plugins-in-mne-scan",children:"Acquisition Plugins in MNE Scan"})}),"\n",(0,t.jsx)(i.p,{children:"Acquisition plugins (also called sensor plugins) are the entry point for all data in MNE Scan. They interface with hardware devices or data sources \u2014 EEG amplifiers, MEG systems, file readers, or simulated signals \u2014 and stream data into the real-time processing pipeline."}),"\n",(0,t.jsx)(i.h2,{id:"three-tier-architecture",children:"Three-Tier Architecture"}),"\n",(0,t.jsx)(i.p,{children:"All acquisition plugins follow a consistent three-tier architecture that separates concerns between the MNE Scan framework, the data acquisition logic, and the hardware driver:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Tier"}),(0,t.jsx)(i.th,{children:"Class Role"}),(0,t.jsx)(i.th,{children:"Responsibilities"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.strong,{children:"Plugin"})," (top)"]}),(0,t.jsxs)(i.td,{children:["Main plugin class, inherits from ",(0,t.jsx)(i.code,{children:"AbstractSensor"})]}),(0,t.jsx)(i.td,{children:"Communicates with MNE Scan; manages the GUI (setup widget, toolbar buttons); creates and owns the Producer"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.strong,{children:"Producer"})," (middle)"]}),(0,t.jsx)(i.td,{children:"Data acquisition controller"}),(0,t.jsx)(i.td,{children:"Manages the acquisition thread; pulls data from the Driver and pushes it into ring buffers; bridges Plugin \u2194 Driver"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.strong,{children:"Driver"})," (bottom)"]}),(0,t.jsx)(i.td,{children:"Hardware/device interface"}),(0,t.jsx)(i.td,{children:"Directly communicates with the device SDK or API; handles device initialization, parameter configuration, and raw sample retrieval"})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"This separation means that the Plugin and Producer classes are structurally similar across all acquisition plugins \u2014 only the Driver class changes significantly depending on the hardware."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         MNE Scan                \u2502\n\u2502  (plugin pipeline framework)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502  \u2190 AbstractSensor interface\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Plugin Class              \u2502\n\u2502  (e.g. GUSBamp, BabyMEG,       \u2502\n\u2502   FiffSimulator, LSLAdapter)    \u2502\n\u2502  \u2022 GUI setup widget             \u2502\n\u2502  \u2022 Start/stop acquisition       \u2502\n\u2502  \u2022 Output connectors            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Producer Class             \u2502\n\u2502  (e.g. GUSBampProducer)         \u2502\n\u2502  \u2022 Runs acquisition thread      \u2502\n\u2502  \u2022 Ring buffer management       \u2502\n\u2502  \u2022 Calls driver for samples     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Driver Class              \u2502\n\u2502  (e.g. GUSBampDriver)           \u2502\n\u2502  \u2022 Device SDK calls             \u2502\n\u2502  \u2022 Parameter configuration      \u2502\n\u2502  \u2022 Raw sample retrieval         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  Hardware  \u2502\n     \u2502  Device    \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(i.h2,{id:"example-gusbamp-eeg-driver",children:"Example: gUSBamp EEG Driver"}),"\n",(0,t.jsx)(i.p,{children:"The gUSBamp plugin illustrates this pattern:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{src:n(77962).A+"",title:"Flow sheet of the gUSBamp acquisition plugin",width:"704",height:"748"})}),"\n",(0,t.jsx)(i.p,{children:"The left side shows the MNE Scan boundary; the right side shows the hardware device. The three classes mediate between them:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"gUSBamp"})," \u2014 main plugin class; communicates with MNE Scan and manages the GUI."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"gUSBampproducer"})," \u2014 controls the acquisition thread and bridges the plugin with the driver."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"gUSBampdriver"})," \u2014 communicates directly with the gUSBamp amplifier hardware."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"data-flow",children:"Data Flow"}),"\n",(0,t.jsx)(i.p,{children:"All three classes are constructed sequentially during plugin initialization, setting up default parameters. Once initialized, the plugin waits for a start command or parameter changes from the GUI."}),"\n",(0,t.jsx)(i.h3,{id:"starting-acquisition",children:"Starting Acquisition"}),"\n",(0,t.jsxs)(i.p,{children:["Starting acquisition triggers a chain: the Plugin starts the Producer, and the Producer starts the Driver. The Driver initializes the hardware and begins sampling. Both the Plugin and Producer run internal threads that pull data from the class below and push it upward via ",(0,t.jsx)(i.strong,{children:"ring buffers"})," (",(0,t.jsx)(i.code,{children:"CircularBuffer"}),"), creating a continuous data stream into MNE Scan."]}),"\n",(0,t.jsx)(i.h3,{id:"stopping-acquisition",children:"Stopping Acquisition"}),"\n",(0,t.jsxs)(i.p,{children:["When stopping the acquisition, both threads are interrupted by setting the ",(0,t.jsx)(i.code,{children:"m_bIsRunning"})," flag to ",(0,t.jsx)(i.code,{children:"false"}),", and the Driver class puts the device into standby mode. The ring buffers are flushed and reset."]}),"\n",(0,t.jsx)(i.h2,{id:"key-base-classes",children:"Key Base Classes"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Class"}),(0,t.jsx)(i.th,{children:"Location"}),(0,t.jsx)(i.th,{children:"Purpose"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"AbstractSensor"})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"src/applications/mne_scan/libs/scShared/"})}),(0,t.jsx)(i.td,{children:"Base class for all acquisition plugins"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"CircularBuffer"})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"src/libraries/utils/"})}),(0,t.jsx)(i.td,{children:"Lock-free ring buffer for inter-thread data transfer"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"PluginOutputData"})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"src/applications/mne_scan/libs/scShared/"})}),(0,t.jsx)(i.td,{children:"Typed output connector that passes data to downstream plugins"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"implementing-a-new-acquisition-plugin",children:"Implementing a New Acquisition Plugin"}),"\n",(0,t.jsx)(i.p,{children:"To create a new acquisition plugin:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Copy"})," an existing plugin folder (e.g., ",(0,t.jsx)(i.code,{children:"dummytoolbox"})," or ",(0,t.jsx)(i.code,{children:"fiffsimulator"}),") as a template."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Create three classes"}),": ",(0,t.jsx)(i.code,{children:"MyPlugin"})," (inherits ",(0,t.jsx)(i.code,{children:"AbstractSensor"}),"), ",(0,t.jsx)(i.code,{children:"MyPluginProducer"}),", and ",(0,t.jsx)(i.code,{children:"MyPluginDriver"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implement the Driver"})," to interface with your device's SDK \u2014 initialize the device, configure parameters, and read raw samples."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implement the Producer"})," to run the acquisition loop in a separate thread, pulling samples from the Driver and pushing them into a ",(0,t.jsx)(i.code,{children:"CircularBuffer"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implement the Plugin"})," to set up the GUI, create output connectors, and manage the start/stop lifecycle."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Register"})," the plugin in the parent ",(0,t.jsx)(i.code,{children:"CMakeLists.txt"})," and, for static builds, in ",(0,t.jsx)(i.code,{children:"main.cpp"})," via ",(0,t.jsx)(i.code,{children:"Q_IMPORT_PLUGIN"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["See ",(0,t.jsx)(i.a,{href:"/docs/development/scan-plugin",children:"Creating a Plugin"})," for the general plugin scaffolding guide."]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},77962(e,i,n){n.d(i,{A:()=>s});const s=n.p+"assets/images/eeg_amp_scan4-9da36e0701d582292d760fa2a6dd632b.png"},28453(e,i,n){n.d(i,{R:()=>a,x:()=>l});var s=n(96540);const t={},r=s.createContext(t);function a(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);